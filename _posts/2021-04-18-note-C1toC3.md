---
layout: article
title: Notes of 17-355/17-665/17-819 Program Analysis, CMU, Chapter 1 to Chapter 3
tag: Program Analysis
aside:
toc: true
sidebar:
nav: layouts
date: 2021-04-18
key: 2021-04-18-note-C1toC3
---

[17-355/17-665/17-819: Program Analysis (cmu-program-analysis.github.io)](https://cmu-program-analysis.github.io/2021/index.html)

[15-819 O: Program Analysis (cmu.edu)](https://www.cs.cmu.edu/~aldrich/courses/15-819O-13sp/)

Book: [program-analysis.pdf (cmu-program-analysis.github.io)](https://cmu-program-analysis.github.io/2021/resources/program-analysis.pdf)



The note is used as supplymentary material of the book.



## C1 Introduction

[01-introduction.pdf (cmu-program-analysis.github.io)](https://cmu-program-analysis.github.io/2021/lecture-slides/01-introduction.pdf)

### Rice's Theorem

[Rice's theorem - Wikipedia](https://en.wikipedia.org/wiki/Rice's_theorem)

> All non-trivial, semantic properties of programs are undecidable.

`semantic property`: about program's behavior. e.g. whether the program will terminal 

`syntactic property`: about program's syntax. e.g. whether the program contains an if-and-else statement

`non-trivial`: A property is *non-trivial* if it is neither true for every partial computable function, nor false for every partial computable function.

Equally, 

Let *S* be a set of languages that is nontrivial, meaning

1. there exists a Turing machine that recognizes a language in *S*,
2. there exists a Turing machine that recognizes a language not in *S*.



#### Proof By reduction to halting problem:

`Halting Problem`: determine from an description of arbitrary program and input, whether the program will finish running or run forever. 

Proved by Alan Turing, an general algorithm to solve halting problem for all possible program-input pairs cannot exist.



Assumption: we have an algorithm for examining a program *p* and determining infallibly whether *p* is an implementation of the squaring function.

Then we can implement an algorithm to solve halting problem 

```c++
int t(program p, input i){
  p(i);
  return i*i;
}

bool halts(program p, input i){
  return is_a_squaring_function(t(p, i));
}
```

as t(p, i) is a squaring function if and only if p(i) will terminate.



#### Sound Analysis v.s. complete Analysis

|                   | Error exists   | No error exists |
| ----------------- | -------------- | --------------- |
| Error reported    | True positive  | False positive  |
| No Error reported | False negative | True negative   |

**Sound** Analysis: reports all defects

- No false negative
- typically overapproximated

**Complete** Analysis: every reported defect is an actual defect

- No false positive
- typically underapproximated

<img src="./pic/2021-04-18-sound-complete.png" alt="sound-complete" style="zoom: 33%;" />



## C2 The WHILE Language and Program Representation



### Concrete syntax v.s. abstract syntax

[Lecture 2: Abstract and Concrete Syntax (chalmers.se)](http://www.cse.chalmers.se/edu/year/2011/course/TIN321/lectures/proglang-02.html)

`Concrete syntax`: The rules by which programs can be expressed as strings of characters.

`Abstract syntax`: a subset of the parse tree of the program.

`Parse tree`: show the concrete syntax (how tokens are grouped together)

- the tree initially constructed by the parser
- e.g.<img src="./pic/2021-04-18-parse-tree.png" alt="parse-tree" style="zoom:33%;" />

`Abstract tree`: show the semantically significant structure

- the tree returned by the parser and manipulated by type checker
- e.g.<img src="./pic/2021-04-18-abstract-tree.png" alt="abstract-tree" style="zoom:50%;" />



### The WHILE Language



### WHILE3ADDR: A Representation for Analysis

source language WHILE -> lower-level intermediate language WHILE3ADDR



## C3 Program Semantics

[02-semantics.pdf (cmu-program-analysis.github.io)](https://cmu-program-analysis.github.io/2021/lecture-slides/02-semantics.pdf)

`Semantics`: three canonical approaches

- `Operational`: specifies how expressions and statements should be evaluated.
  - Abstraction of the execution of a concrete interpreter
- `Axiomatic`: define the meaning of a command in a program by describing its effect on assertions about the program state.
- `Denotational`: concerned with finding mathematical objects called domains that represent what programs do. 
  - programs (or program phrases) might be represented by partial functions.
  - What function is this trying to compute?



### Operational Sematics

`Operational Sematics`:

- `Big-step semantics` (aka. `natural operational semantics`)
- `Small-step semantics` (aka. `structural operational semantics`)



#### Big-step operational semantics

##### Notation

- `Judgement`: $ \langle E, a \rangle \Downarrow n$
  - given program state E, the arithmetic expression a evaluates to n.
- `Rules of Inference`: $\frac{premise_1 \, premise_2 \, â€¦ premise_n}{conclusion}$
  - `axiom`: an inference rule with no premises, always true.
- $E[x \mapsto n]$
  - a new state that is the same as $E$ except that $x$ is mapped to $n$
  - Definition: $E[x \mapsto n](x) = n$, $E[x \mapsto n](y) = E(y)$



##### Rules for `while` construct

$$
\frac{\langle E,P \rangle \Downarrow false}{\langle E, while\, P \, do \, S \rangle \Downarrow E} \\
\frac{\langle E, P \rangle \Downarrow true \quad \langle E, S; while\, P \, do \, S \rangle \Downarrow E'}{\langle E, while\, P \, do \, S \rangle \Downarrow E'}
$$



##### Issues & disadvantages

- The evaluation rules are not syntax-directed

- hard to talk about statements whose evaluation does not terminate. e.g. no $E'$ such that $\langle E, S \rangle \Downarrow E'$
- **It does not give us a way to talk about intermediate states.**
  - Thus we cannot say that on a parallel machine the execution of two commands is interleaved (= no modeling threads)



#### Small-step operational semantics

##### Notation

- `Configuration`: $\langle E, S \rangle$
  - def: a pair of state and statement

##### Relation

Small-step `Judgement`

- one step: $\langle E, S \rangle \rightarrow \langle E', S' \rangle$. $S'$ is obtained from $S$ via a **rewrite step**.
- 0 or more steps: $\langle E, S \rangle \rightarrow^* \langle E', S' \rangle$
- basically one judgement per grammar production

Big step judgement relates a configuration to a new **state**: $\langle E, S \rangle \Downarrow E'$

Small step judgement relates a configuration to a new **configuration**: $\langle E, S \rangle \rightarrow \langle E', S' \rangle$

##### Execution

Key idea:

- Execution is modeled as a (possible infinite) **sequence of states** (solve big-step's termination & intermediate state problem)
- Each atomic execution step **rewrites** the program.

e.g. 
$$
E(x) = 5 \\
\langle E, x+(7-3) \rangle \rightarrow \langle E, x+(4) \rangle \rightarrow \langle E, 5+4 \rangle \rightarrow \langle E, 9 \rangle
$$


Terminal: 

- Evaluation terminates when the program has been rewritten to a **terminal program** (which can't be made further progress from). 
- In other word, reach a `final configuration` ($\langle E, skip \rangle$ in WHILE)



#### WHILE3ADDR: Small-step semantics

`Judgement`: $P \vdash \langle E, n \rangle \leadsto \langle E', n' \rangle $

When executing the program $P$, executing instruction $n$ in the state $E$ steps to a new state $E'$  and program counter $n'$ .



### Derivations and Provability

$\langle E, a \rangle \Downarrow n$ is provable (aka. $\vdash \langle E, a \rangle \Downarrow n$) if there exists a well-formed derivation with $\langle E, a \rangle \Downarrow n$ as its conclusion.



